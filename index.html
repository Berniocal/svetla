<!doctype html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Barvy ‚Äì multiplayer</title>
<link rel="manifest" href="./manifest.json">
  <meta name="theme-color" content="#111111" />
  <style>
    :root { --bg:#0f1115; --card:#171a22; --text:#e9ecf1; --muted:#aab2c0; }
    html,body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background: var(--bg); color: var(--text); }
    .wrap { max-width: 560px; margin: 0 auto; padding: 16px; }
    .card { background: var(--card); border-radius: 16px; padding: 14px; margin: 10px 0; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    input, button, select { font-size: 16px; padding: 12px 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,.12); background: #0f1218; color: var(--text); }
    input { width: 100%; box-sizing: border-box; }
    button { cursor:pointer; border: 0; background: #2a66ff; }
    button.secondary { background:#2b3242; }
    button.danger { background:#d64545; }
    .muted { color: var(--muted); font-size: 13px; line-height: 1.35; }
    .big { font-size: 20px; font-weight: 700; }
    .code { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; letter-spacing: 2px; font-size: 22px; }
    .pill { padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,.08); font-size: 13px; }
    .table { width:100%; border-collapse: collapse; font-size: 14px; }
    .table th,.table td { padding: 8px; border-bottom: 1px solid rgba(255,255,255,.08); text-align:left; }

    /* Fullscreen color */
    .fullScreen {
      position: fixed; inset: 0; display: none;
      align-items: center; justify-content: center; flex-direction: column;
      touch-action: none;
    }
    .fsText { font-size: 34px; font-weight: 900; text-shadow: 0 2px 14px rgba(0,0,0,.35); }
    .fsSub { margin-top: 10px; font-size: 14px; opacity:.9; }
    .tapHint { margin-top: 18px; font-size: 16px; padding: 10px 14px; border-radius: 999px; background: rgba(0,0,0,.18); }

    /* Fullscreen idle (ztmaven√≠) */
    .idleScreen{
      position: fixed; inset: 0;
      display: none;
      background: #000;
      touch-action: none;
    }

    /* ‚úÖ NOV√â: editor barev */
    .colorList { display:flex; flex-direction:column; gap:10px; margin-top:10px; }
    .colorRow {
      display:grid;
      grid-template-columns: 44px 1fr 1fr 110px;
      gap:10px;
      align-items:center;
      padding:10px;
      border-radius:14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.12);
    }
    .colorRow input[type="color"]{
      width:44px; height:44px; padding:0; border-radius:12px; border: 1px solid rgba(255,255,255,.18);
      background: transparent;
    }
    .smallInput { padding: 10px 12px; border-radius: 12px; font-size: 15px; }
    .previewPill{
      justify-self:end;
      display:flex;
      gap:8px;
      align-items:center;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      font-size: 13px;
      max-width: 110px;
      overflow:hidden;
      white-space:nowrap;
      text-overflow:ellipsis;
    }
    .swatch{
      width:14px; height:14px; border-radius: 4px;
      box-shadow: 0 0 0 1px rgba(0,0,0,.25);
      flex: 0 0 auto;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
html, body{
  overscroll-behavior: none;   /* blokuje pull-to-refresh */
}


  </style>
</head>
<body>
  <!-- KEEP AWAKE VIDEO (neviditeln√©) -->
<video id="keepAwakeVideo"
  playsinline
  muted
  loop
  preload="auto"
  style="position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;opacity:0;">
  <source
    src="data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAACBtZGF0AAAAAA=="
    type="video/mp4">
</video>
  <div class="wrap" id="appWrap">
    <div class="card">
      <div class="big">Multiplayer ‚ÄûBarvy na telefonech‚Äú12</div>
      <div class="muted">Host jen ovl√°d√° a vid√≠ v√Ωsledky. Hern√≠ telefony jsou bƒõhem hry buƒè barva fullscreen, nebo √∫pln√° tma.</div>
    </div>

    <div class="card" id="joinCard">
      <div class="row">
        <div class="pill" id="rolePill">Nep≈ôipojeno</div>
        <div class="pill" id="connPill">offline</div>
      </div>
      <div style="height:10px"></div>

      <label class="muted">Tvoje p≈ôezd√≠vka (voliteln√©)</label>
      <input id="nameInput" placeholder="nap≈ô. Honza" />

      <div style="height:10px"></div>
      <label class="muted">K√≥d m√≠stnosti (5 ƒç√≠slic)</label>
      <input id="codeInput" inputmode="numeric" maxlength="5" placeholder="12345" />

      <div style="height:10px"></div>
      <div class="row">
        <button id="btnJoin">P≈ôipojit / zalo≈æit</button>
        <button class="secondary" id="btnRandom">Vygenerovat k√≥d</button>
      </div>
      <div class="muted" style="margin-top:8px">
        Prvn√≠ telefon, kter√Ω m√≠stnost zalo≈æ√≠, je <b>host</b>. Host nen√≠ souƒç√°st√≠ hry.
      </div>
    </div>

    <div class="card" id="hostCard" style="display:none">
      <div class="big">Host ‚Äì nastaven√≠</div>
      <div class="muted">Poƒçet hr√°ƒç≈Ø = poƒçet barev. ƒåas na stisk = timeout. D√©lka hry = automatick√Ω stop.</div>

      <div style="height:10px"></div>
      <label class="muted">Poƒçet hr√°ƒç≈Ø (2‚Äì10)</label>
      <select id="playersCount">
        <option>2</option><option>3</option><option selected>4</option><option>5</option><option>6</option>
        <option>7</option><option>8</option><option>9</option><option>10</option>
      </select>

      <div style="height:10px"></div>
      <label class="muted">ƒåas na stisk (ms)</label>
      <input id="durationMs" inputmode="numeric" value="2500" />

      <div style="height:10px"></div>
      <label class="muted">D√©lka hry (s) ‚Äì po vypr≈°en√≠ se sama zastav√≠</label>
      <input id="gameLengthSec" inputmode="numeric" value="30" />

      <!-- ‚úÖ NOV√â: Konfigurace barev -->
      <div style="height:14px"></div>
      <div class="big" style="font-size:16px">Barvy + jm√©no + emoji</div>
      <div class="muted">Pou≈æije se prvn√≠ch <span class="mono" id="playersCountMirror">4</span> ≈ô√°dk≈Ø. Jm√©no je voliteln√©. Emoji m≈Ø≈æe b√Ωt t≈ôeba üî¥ üü¢ üü° ‚ö°Ô∏è üê∏.</div>

      <div class="colorList" id="colorList"></div>

      <div style="height:12px"></div>
      <div class="row">
        <button id="btnApply">Ulo≈æit nastaven√≠</button>
        <button id="btnStart">Start hry</button>
        <button class="danger" id="btnStop">Stop</button>
        <button class="secondary" id="btnReset">Vynulovat sk√≥re</button>
      </div>

      <div style="height:10px"></div>
      <div class="muted">P≈ôipojen√© telefony (vƒçetnƒõ hosta): <span id="devicesCount">0</span></div>
    </div>

    <div class="card" id="statusCard" style="display:none">
      <div class="row">
        <div class="pill">M√≠stnost: <span class="code" id="roomCodeLabel">-----</span></div>
        <div class="pill">Kolo: <span id="roundLabel">0</span></div>
        <div class="pill">Stav: <span id="phaseLabel">-</span></div>
    <div class="pill">Zb√Ωv√°: <span id="countdownLabel">‚Äî</span></div>
      </div>
      <div style="height:10px"></div>
      <div class="muted" id="statusLine">ƒåek√°m‚Ä¶</div>
    </div>

    <div class="card" id="scoreCard" style="display:none">
      <div class="big">Sk√≥re</div>
      <table class="table" id="scoreTable">
        <thead>
          <tr><th>Barva</th><th>Body</th><th>Pr≈Øm. ƒças (ms)</th><th>Miss</th></tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="muted" style="margin-top:8px">Tip: Polo≈æ telefony po zemi, zapni jas a vypni usp√°v√°n√≠ displeje.</div>
    </div>
  </div>

<!-- Fullscreen color -->
<div class="fullScreen" id="fs">

  <!-- üé• VIDEO POZAD√ç -->
  <video id="bgVideo"
         autoplay
         muted
         loop
         playsinline
         preload="auto"
         style="
           position:absolute;
           inset:0;
           width:100%;
           height:100%;
           object-fit:cover;
           z-index:0;
           opacity:0.25;">
    <source src="video.mp4" type="video/mp4">
  </video>

  <!-- OBSAH NAD VIDEEM -->
  <div style="position:relative; z-index:1; text-align:center;">
    <div class="fsText" id="fsText">Tvoje barva!</div>
    <div class="tapHint">Klepni kamkoliv</div>
    <div class="fsSub" id="fsSub">‚Ä¶</div>
  </div>

</div>

  <!-- Fullscreen idle (ztmaven√≠) -->
  <div class="idleScreen" id="idle"></div>

  <!-- Firebase (compat for simple CDN usage) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-database-compat.js"></script>

  <script>
    // ========== 0) Firebase config ==========
    const firebaseConfig = {
      apiKey: "AIzaSyDgMBr7Qv_EEa83TWS174eJdQW9xbgcSX0",
      authDomain: "barvy-multiplayer.firebaseapp.com",
      databaseURL: "https://barvy-multiplayer-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "barvy-multiplayer",
      storageBucket: "barvy-multiplayer.appspot.com",
      messagingSenderId: "1013627563036",
      appId: "1:1013627563036:web:83e19f570dd9a51d9143d9"
    };
    // =======================================

    // PWA SW
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("./sw.js").catch(()=>{});
    }

    // Helpers
    const $ = (id)=>document.getElementById(id);
    const now = ()=>Date.now();
    const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
    const randInt = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
// ================= KEEP AWAKE =================
const keepAwakeVideo = document.getElementById("keepAwakeVideo");
let wakeLock = null;

async function keepAwakeStart(){
  try {
    if ("wakeLock" in navigator && !wakeLock) {
      wakeLock = await navigator.wakeLock.request("screen");
      wakeLock.addEventListener("release",()=>wakeLock=null);
    }
  } catch {}

  try {
    await keepAwakeVideo.play();
  } catch {}
}

async function keepAwakeStop(){
  try {
    if (wakeLock) await wakeLock.release();
  } catch {}
  wakeLock = null;

  try {
    keepAwakeVideo.pause();
    keepAwakeVideo.currentTime = 0;
  } catch {}
}

document.addEventListener("visibilitychange", ()=>{
  if (document.visibilityState === "visible") {
    keepAwakeStart();
  }
});
// ==============================================
    function shuffle(arr){
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    }

    // Device identity
    const deviceId = (() => {
      const k = "barvy_deviceId";
      let v = localStorage.getItem(k);
      if (!v) { v = "d_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16); localStorage.setItem(k,v); }
      return v;
    })();

    // UI refs
    const appWrap = $("appWrap");
    const joinCard = $("joinCard");
    const hostCard = $("hostCard");
    const statusCard = $("statusCard");
    const scoreCard = $("scoreCard");
    const rolePill = $("rolePill");
    const connPill = $("connPill");

    const nameInput = $("nameInput");
    const codeInput = $("codeInput");
    const btnJoin = $("btnJoin");
    const btnRandom = $("btnRandom");

    const playersCount = $("playersCount");
    const durationMs = $("durationMs");
    const gameLengthSec = $("gameLengthSec");

    const btnApply = $("btnApply");
    const btnStart = $("btnStart");
    const btnStop = $("btnStop");
    const btnReset = $("btnReset");
    const devicesCount = $("devicesCount");

    const roomCodeLabel = $("roomCodeLabel");
    const statusLine = $("statusLine");
    const roundLabel = $("roundLabel");
    const phaseLabel = $("phaseLabel");
    const countdownLabel = $("countdownLabel");

    const scoreTableBody = $("scoreTable").querySelector("tbody");

    const fs = $("fs");
    const fsText = $("fsText");
    const fsSub = $("fsSub");
    const idle = $("idle");
function isGameScreenActive(){
  return (fs.style.display !== "none" && fs.style.display !== "") || (idle.style.display === "block");
}

// blokuj posouv√°n√≠ a pull-to-refresh bƒõhem hry
document.addEventListener("touchmove", (e) => {
  if (isGameScreenActive()) e.preventDefault();
}, { passive:false });

document.addEventListener("wheel", (e) => {
  if (isGameScreenActive()) e.preventDefault();
}, { passive:false });

// blokuj ‚Äûdvojtap zoom‚Äú + dal≈°√≠ gesta bƒõhem hry
document.addEventListener("gesturestart", (e) => {
  if (isGameScreenActive()) e.preventDefault();
}, { passive:false });

    // ‚úÖ NOV√â: UI pro barvy
    const colorListEl = $("colorList");
    const playersCountMirror = $("playersCountMirror");

    // Colors defaults (a≈æ 10) ‚Äì kl√≠ƒçe jsou stabiln√≠ pozice barvy (c1..c10)
    const DEFAULT_COLOR_CONFIG = [
      { key:"c1", label:"ƒåerven√°",  css:"#ff3b30", emoji:"üî¥" },
      { key:"c2", label:"Zelen√°",   css:"#34c759", emoji:"üü¢" },
      { key:"c3", label:"Modr√°",    css:"#007aff", emoji:"üîµ" },
      { key:"c4", label:"≈Ωlut√°",    css:"#ffd60a", emoji:"üü°" },
      { key:"c5", label:"Fialov√°",  css:"#af52de", emoji:"üü£" },
      { key:"c6", label:"Oran≈æov√°", css:"#ff9500", emoji:"üü†" },
      { key:"c7", label:"R≈Ø≈æov√°",   css:"#ff2d55", emoji:"üå∏" },
      { key:"c8", label:"Azurov√°",  css:"#5ac8fa", emoji:"üíß" },
      { key:"c9", label:"Limet",    css:"#bfff00", emoji:"üçã" },
      { key:"c10",label:"B√≠l√°",     css:"#ffffff", emoji:"‚ö™Ô∏è" },
    ];

    // ‚úÖ NOV√â: aktu√°ln√≠ konfigurace (m≈Ø≈æe p≈ôij√≠t ze state)
    let currentColorConfig = DEFAULT_COLOR_CONFIG.slice();

    function normalizeEmoji(s){
      const t = (s || "").trim();
      if (!t) return "";
      // nech√°me u≈æivateli i v√≠c znak≈Ø (nap≈ô. ‚ö°Ô∏è), ale o≈ô√≠zneme ≈°√≠lenƒõ dlouh√©
      return t.length > 6 ? t.slice(0,6) : t;
    }

    function safeLabel(s){
      return (s || "").trim();
    }

    function activeConfigForPlayers(n){
      const nn = clamp(parseInt(n||4,10),2,10);
      return (currentColorConfig || DEFAULT_COLOR_CONFIG).slice(0, nn);
    }

    function configByKey(k){
      const cfg = (currentColorConfig || DEFAULT_COLOR_CONFIG).find(x=>x.key===k);
      return cfg || { key:k, label:"", css:"#222", emoji:"" };
    }

    // ‚úÖ NOV√â: vykreslen√≠ editoru barev
    function renderColorEditor(){
      colorListEl.innerHTML = "";
      const n = clamp(parseInt(playersCount.value||4,10),2,10);
      playersCountMirror.textContent = String(n);

      // zajisti d√©lku 10
      if (!currentColorConfig || currentColorConfig.length !== 10){
        const map = new Map((currentColorConfig||[]).map(x=>[x.key,x]));
        currentColorConfig = DEFAULT_COLOR_CONFIG.map(d => {
          const v = map.get(d.key);
          return v ? { key:d.key, label: v.label ?? d.label, css: v.css ?? d.css, emoji: v.emoji ?? d.emoji } : {...d};
        });
      }

      for (let i=0;i<10;i++){
        const cfg = currentColorConfig[i];
        const enabled = (i < n);
        const row = document.createElement("div");
        row.className = "colorRow";
        row.style.opacity = enabled ? "1" : ".45";

        const color = document.createElement("input");
        color.type = "color";
        color.value = cfg.css || "#222222";
        color.disabled = !enabled;

        const label = document.createElement("input");
        label.className = "smallInput";
        label.placeholder = "Jm√©no (voliteln√©)";
        label.value = cfg.label || "";
        label.disabled = !enabled;

        const emoji = document.createElement("input");
        emoji.className = "smallInput";
        emoji.placeholder = "Emoji";
        emoji.value = cfg.emoji || "";
        emoji.disabled = !enabled;

        const preview = document.createElement("div");
        preview.className = "previewPill";
        const sw = document.createElement("div");
        sw.className = "swatch";
        sw.style.background = cfg.css || "#222";
        const txt = document.createElement("div");
        txt.style.overflow = "hidden";
        txt.style.textOverflow = "ellipsis";
        txt.style.whiteSpace = "nowrap";
        txt.textContent = `${(cfg.emoji||"").trim()} ${((cfg.label||"") || ("Barva " + (i+1)))}`.trim();

        preview.appendChild(sw);
        preview.appendChild(txt);

        const sync = () => {
          cfg.css = color.value;
          cfg.label = safeLabel(label.value);
          cfg.emoji = normalizeEmoji(emoji.value);
          sw.style.background = cfg.css || "#222";
          txt.textContent = `${(cfg.emoji||"").trim()} ${((cfg.label||"") || ("Barva " + (i+1)))}`.trim();
        };

        color.addEventListener("input", sync);
        label.addEventListener("input", sync);
        emoji.addEventListener("input", sync);

        row.appendChild(color);
        row.appendChild(label);
        row.appendChild(emoji);
        row.appendChild(preview);

        colorListEl.appendChild(row);
      }
    }

    playersCount.addEventListener("change", () => {
      renderColorEditor();
    });

    // Firebase state
    let app, db;
    let roomCode = null;
    let isHost = false;
    let roomRef = null;
    let stateRef = null;
    let devicesRef = null;
    let actionsRef = null;
    let playersRef = null;

    // ‚úÖ hostAlive
    let hostAliveRef = null;

    // ‚úÖ my device ref
    let myDeviceRef = null;

    // Host runtime
    let hostRunning = false;
    let tapLocked = false;
    let lastAssignedColorKey = null;
    let stopTimer = null;
    let countdownTimer = null;

    // host ticker
    let hostTickTimer = null;

    function setConn(ok) {
      connPill.textContent = ok ? "online" : "offline";
      connPill.style.background = ok ? "rgba(52,199,89,.18)" : "rgba(214,69,69,.18)";
    }

    function genCode() { return String(randInt(0,99999)).padStart(5,"0"); }

    function renderScore(playersObj) {
      scoreTableBody.innerHTML = "";
      if (!playersObj) return;
      Object.values(playersObj).forEach(p => {
        const avg = p.hits > 0 ? Math.round(p.totalMs / p.hits) : "‚Äî";

        const tr = document.createElement("tr");

        const labelTxt = `${(p.emoji||"").trim()} ${(p.label||"").trim()}`.trim() || "‚Äî";

        tr.innerHTML = `
          <td>
            <span class="swatch" style="display:inline-block; vertical-align:middle; margin-right:8px; background:${p.css||"#222"}"></span>
            <span style="vertical-align:middle;">${labelTxt}</span>
          </td>
          <td>${p.hits||0}</td>
          <td>${avg}</td>
          <td>${p.miss||0}</td>
        `;
        scoreTableBody.appendChild(tr);
      });
    }

    function hideUI(){ appWrap.style.display = "none"; }
    function showUI(){ appWrap.style.display = ""; }

    function showFullscreen(colorCss, label, extra) {
       tapLocked = false;
  keepAwakeStart();   // ‚Üê P≈òIDAT
  hideUI();
  idle.style.display = "none";
  fs.style.display = "flex";
  fs.style.background = colorCss;
  fsText.textContent = label;
  fsSub.textContent = extra || "";
}
    function hideFullscreen() {
      fs.style.display = "none";
    }
    function showIdle() {
  keepAwakeStart();   // ‚Üê P≈òIDAT
  hideUI();
  hideFullscreen();
  idle.style.display = "block";
}
    function hideIdle() {
      idle.style.display = "none";
    }

    async function leaveRoom(reason){
      stopHostCountdown();
      try { hostRunning = false; } catch {}
      try { clearTimeout(stopTimer); } catch {}
      try { if (hostTickTimer) { clearInterval(hostTickTimer); hostTickTimer = null; } } catch {}

      try { hideFullscreen(); hideIdle(); } catch {}
      try { showUI(); } catch {}

      try {
        if (devicesRef) devicesRef.off();
        if (playersRef) playersRef.off();
        if (stateRef) stateRef.off();
        if (actionsRef) actionsRef.off();
        if (hostAliveRef) hostAliveRef.off();
      } catch {}

      try { if (myDeviceRef) await myDeviceRef.remove(); } catch {}

      try {
        hostCard.style.display = "none";
        joinCard.style.display = "";
        statusCard.style.display = "none";
        scoreCard.style.display = "none";
        rolePill.textContent = "Nep≈ôipojeno";
        rolePill.style.background = "rgba(255,255,255,.08)";
        phaseLabel.textContent = "-";
        statusLine.textContent = reason ? ("Odpojeno: " + reason) : "Odpojeno.";
      } catch {}

      roomCode = null;
      isHost = false;
      roomRef = null;
      stateRef = null;
      devicesRef = null;
      actionsRef = null;
      playersRef = null;
      hostAliveRef = null;
      myDeviceRef = null;
    }

    async function ensureFirebase() {
      if (!app) {
        app = firebase.initializeApp(firebaseConfig);
        db = firebase.database();
        db.ref(".info/connected").on("value", (snap) => setConn(!!snap.val()));
      }
    }

    async function joinOrCreate(code) {
      await ensureFirebase();
      roomCode = code;
      roomRef = db.ref("rooms/" + roomCode);
      stateRef = roomRef.child("state");
      devicesRef = roomRef.child("devices");
      actionsRef = roomRef.child("actions");
      playersRef = roomRef.child("players");
      hostAliveRef = roomRef.child("hostAlive");

      roomCodeLabel.textContent = roomCode;
      statusCard.style.display = "";
      scoreCard.style.display = "";

      // presence
      const myName = (nameInput.value || "").trim() || "Telefon";
      myDeviceRef = devicesRef.child(deviceId);
      await myDeviceRef.set({ name: myName, joinedAt: now(), lastSeen: now() });
      myDeviceRef.onDisconnect().remove();
      setInterval(()=> myDeviceRef.update({ lastSeen: now() }).catch(()=>{}), 5000);
// ‚úÖ OKAM≈ΩIT√â odhl√°≈°en√≠ p≈ôi zamknut√≠ / odchodu / skryt√≠ str√°nky
let presenceTicker = null;

function startPresenceTicker(){
  if (presenceTicker) return;
  presenceTicker = setInterval(() => {
    if (myDeviceRef) myDeviceRef.update({ lastSeen: now() }).catch(()=>{});
  }, 2000); // rychlej≈°√≠ heartbeat (2 s)
}

async function hardLeaveNow(reason){
  try { keepAwakeStop(); } catch {}
  try {
    // odstran√≠ mƒõ z devices (jen pokud je≈°tƒõ m√°me p≈ôipojen√≠)
    if (myDeviceRef) await myDeviceRef.remove();
  } catch {}
  // UI si m≈Ø≈æe≈° nechat jak chce≈°; j√° doporuƒçuju n√°vrat do lobby:
  try { await leaveRoom(reason || "Telefon ode≈°el"); } catch {}
}

startPresenceTicker();

// kdy≈æ u≈æivatel appku schov√° / zamkne telefon
document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "hidden") {
    hardLeaveNow("Telefon ode≈°el (zamknut√≠ / p≈ôepnut√≠ aplikace)");
  }
});

// iOS/Safari ƒçasto spolehlivƒõji vol√° pagehide ne≈æ beforeunload
window.addEventListener("pagehide", () => {
  hardLeaveNow("Telefon ode≈°el");
});

      // determine host
      const snap = await stateRef.child("hostId").get();
      if (!snap.exists()) {
        try {
          const res = await stateRef.child("hostId").transaction(v => v || deviceId);
          isHost = res.committed && res.snapshot.val() === deviceId;
        } catch { isHost = false; }
      } else {
        isHost = (snap.val() === deviceId);
      }

      // host alive / cleanup
      if (isHost) {
        try {
          await hostAliveRef.set({ id: deviceId, at: now() });
          hostAliveRef.onDisconnect().remove();

          stateRef.onDisconnect().remove();
          actionsRef.onDisconnect().remove();
          playersRef.onDisconnect().remove();
        } catch {}
      }

      rolePill.textContent = isHost ? "HOST" : "HR√Åƒå";
      rolePill.style.background = isHost ? "rgba(42,102,255,.22)" : "rgba(255,214,10,.18)";
      hostCard.style.display = isHost ? "" : "none";

      // kdy≈æ host zmiz√≠, hr√°ƒçi odejdou
      if (!isHost) {
        hostAliveRef.on("value", (s) => {
          if (!s.exists()) {
            leaveRoom("Host ode≈°el ‚Äì m√≠stnost zru≈°ena");
          }
        });
      }

      // init defaults if host and missing
      if (isHost) {
        const st = await stateRef.get();
        if (!st.exists() || !st.val()?.phase) await initRoomDefaults();
        // ‚úÖ editor barev vykresli a≈æ teƒè (host)
        renderColorEditor();
      }

      // devices count
      devicesRef.on("value", snap2 => {
        const v = snap2.val() || {};
        devicesCount.textContent = Object.keys(v).length;
      });

      // players score
      playersRef.on("value", snap2 => renderScore(snap2.val()));

      // state
      stateRef.on("value", snap2 => onState(snap2.val() || {}));

      // actions (host only)
      if (isHost) {
        actionsRef.limitToLast(200).on("child_added", snap2 => onAction(snap2.val()));
      }

      // host cleanup best-effort
      if (isHost) {
  const hostCleanup = async () => {
    try {
      console.log("üî• Host ode≈°el ‚Äì ma≈æu celou m√≠stnost");
      await roomRef.remove(); // üí• TOTO JE KL√çƒå
    } catch (e) {
      console.warn("Cleanup failed", e);
    }
  };

  window.addEventListener("pagehide", hostCleanup);
  window.addEventListener("beforeunload", hostCleanup);
}
    }

    // ‚úÖ NOV√â: vezmi colorConfig ze state, nebo nech default
    function applyColorConfigFromState(st){
      const cfg = st && st.colorConfig;
      if (Array.isArray(cfg) && cfg.length) {
        // znormalizuj na 10 polo≈æek podle DEFAULT key order
        const map = new Map(cfg.map(x=>[x.key,x]));
        currentColorConfig = DEFAULT_COLOR_CONFIG.map(d => {
          const v = map.get(d.key);
          return v ? {
            key: d.key,
            css: (v.css || d.css),
            label: (v.label ?? d.label),
            emoji: (v.emoji ?? d.emoji)
          } : {...d};
        });
      } else {
        currentColorConfig = DEFAULT_COLOR_CONFIG.slice();
      }

      // kdy≈æ jsem host, a UI existuje, udr≈æ n√°hled editoru synchronn√≠
      if (isHost && hostCard.style.display !== "none") {
        renderColorEditor();
      }
    }

    async function initRoomDefaults() {
      const n = clamp(parseInt(playersCount.value,10)||4,2,10);
      const dur = clamp(parseInt(durationMs.value,10)||1800,200,20000);
      const gls = clamp(parseInt(gameLengthSec.value,10)||60,1,36000);

      // ‚úÖ NOV√â: ulo≈æ√≠me do state i konfiguraci barev
      const cfg = (currentColorConfig || DEFAULT_COLOR_CONFIG).map(x => ({
        key: x.key,
        css: x.css,
        label: safeLabel(x.label),
        emoji: normalizeEmoji(x.emoji)
      }));

      // ‚úÖ NOV√â: playersRef bude podle prvn√≠ch N konfigurac√≠
      const active = cfg.slice(0, n);
      const players = {};
      for (let i=0;i<n;i++) {
        const c = active[i];
        const fallbackName = "Barva " + (i+1);
        const label = (c.label && c.label.trim()) ? c.label.trim() : fallbackName;
        const emoji = (c.emoji && c.emoji.trim()) ? c.emoji.trim() : "";
        players[c.key] = { key:c.key, label:label, css:c.css, emoji:emoji, hits:0, miss:0, totalMs:0 };
      }
      await playersRef.set(players);

      await stateRef.update({
        phase: "lobby",
        playersCount: n,
        durationMs: dur,
        gameLengthSec: gls,

        round: 0,
        currentDevice: null,
        currentColor: null,
        shownAt: null,
        resolved: false,

        hostRunning: false,
        gameStartedAt: null,
        gameEndsAt: null,

        deviceColors: null,
        shownAtMap: null,

        // ‚úÖ NOV√â:
        colorConfig: cfg
      });
    }

    function onState(st) {
      roundLabel.textContent = st.round || 0;
      phaseLabel.textContent = st.phase || "-";

      // ‚úÖ NOV√â: v≈ædy aplikuj config ze state
      applyColorConfigFromState(st);

      if (isHost) {
  showUI();
  hideFullscreen();
  hideIdle();

  if (st.phase === "running" && st.gameEndsAt) {
    statusLine.textContent = "Hra bƒõ≈æ√≠‚Ä¶ (host nen√≠ ve h≈ôe)";
    startHostCountdown(st.gameEndsAt);
  } else {
    stopHostCountdown();
    statusLine.textContent =
      st.phase === "lobby"
        ? "Lobby ‚Äì nastav a dej Start."
        : (st.phase === "stopped" ? "Stop." : "‚Ä¶");
  }
  return;
}

      if (st.phase === "lobby") {
        showUI();
        statusLine.textContent = "Lobby ‚Äì ƒçek√°m na start od hosta‚Ä¶";
        hideFullscreen(); hideIdle();
        return;
      }

      if (st.phase === "running") {
        const dc = st.deviceColors || {};
        const myColorKey = dc[deviceId] || null;

if (myColorKey) {
  // ‚úÖ kdy≈æ mi (znovu) p≈ôi≈ôad√≠ barvu, odemkni tap pro toto zobrazen√≠
  if (myColorKey !== lastAssignedColorKey) {
    tapLocked = false;
    lastAssignedColorKey = myColorKey;
  } else {
    // i kdyby se omylem p≈ôi≈ôadila stejn√° barva znovu, dovol dal≈°√≠ kolo
    tapLocked = false;
  }

  const c = configByKey(myColorKey);
  const niceName = (c.label && c.label.trim()) ? c.label.trim() : "Tvoje barva";
  const niceEmoji = (c.emoji && c.emoji.trim()) ? (c.emoji.trim() + " ") : "";

  showFullscreen(c.css || "#222", (niceEmoji + niceName).trim(), "Klepni kamkoliv");
} else {
  // kdy≈æ jsem idle, taky je bezpeƒçn√© odemknout
  tapLocked = false;
  lastAssignedColorKey = null;
  showIdle();
}
return;

      }

      if (st.phase === "stopped") {
        showUI();
        statusLine.textContent = "Stop.";
        hideFullscreen(); hideIdle();
      }
    }

function startHostCountdown(gameEndsAt){
  stopHostCountdown();

  function tick(){
    const remainingMs = gameEndsAt - Date.now();
    if (remainingMs <= 0) {
      countdownLabel.textContent = "0:00";
      stopHostCountdown();
      return;
    }

    const totalSec = Math.ceil(remainingMs / 1000);
    const min = Math.floor(totalSec / 60);
    const sec = totalSec % 60;

    countdownLabel.textContent = `${min}:${sec.toString().padStart(2,"0")}`;
  }

  tick();
  countdownTimer = setInterval(tick, 250);
}

function stopHostCountdown(){
  if (countdownTimer) {
    clearInterval(countdownTimer);
    countdownTimer = null;
  }
  if (countdownLabel) {
    countdownLabel.textContent = "‚Äî";
  }
}
    
    // ====== HOST HELPERS ======
// ‚úÖ HOST: vyhoƒè telefony, kter√© se nehl√°s√≠ (ghosts)
async function hostPruneGhosts(){
  const snap = await devicesRef.get();
  const devs = snap.val() || {};
  const cutoff = now() - 6000; // 6 s bez heartbeat = pryƒç

  const toRemove = [];
  for (const [id, info] of Object.entries(devs)){
    const ls = info?.lastSeen || 0;
    if (ls < cutoff) toRemove.push(id);
  }

  if (!toRemove.length) return;

  // sma≈æ je z devices
  const upd = {};
  for (const id of toRemove) upd[id] = null;
  await devicesRef.update(upd);

  // a oprav deviceColors (kdy≈æ byli ve h≈ôe)
  const st = (await stateRef.get()).val() || {};
  let dc = st.deviceColors || {};
  let shownAtMap = st.shownAtMap || {};
  let changed = false;

  for (const id of toRemove){
    if (id in dc) { delete dc[id]; changed = true; }
    if (id in shownAtMap) { delete shownAtMap[id]; changed = true; }
  }

  if (changed){
    await stateRef.update({ deviceColors: dc, shownAtMap: shownAtMap });
  }
}

    async function getHostId(){
      return (await stateRef.child("hostId").get()).val();
    }

    async function getConnectedGameDevices() {
      const devSnap = await devicesRef.get();
      const devObj = devSnap.val() || {};
      let ids = Object.keys(devObj);

      const hostId = await getHostId();
      ids = ids.filter(id => id !== hostId);
      return ids;
    }

    function getActiveColorKeys(nPlayers){
      const cfg = (currentColorConfig || DEFAULT_COLOR_CONFIG).slice(0, nPlayers);
      return cfg.map(c => c.key);
    }

    function buildInitialDeviceColors(gameDevices, nPlayers) {
      const ids = shuffle(gameDevices);
      const dc = {};
      const shownAtMap = {};
      const colorKeys = getActiveColorKeys(nPlayers);

      for (const id of ids) dc[id] = null;

      for (let i=0;i<nPlayers;i++){
        const devId = ids[i];
        const colorKey = colorKeys[i];
        dc[devId] = colorKey;
        shownAtMap[devId] = now();
      }

      return { dc, shownAtMap };
    }

    function getColoredDevices(dc){
      return Object.keys(dc || {}).filter(d=>!!dc[d]);
    }
    function getIdleDevices(dc){
      return Object.keys(dc || {}).filter(d=>!dc[d]);
    }

    async function hostHandleEventForDevice(deviceIdThatTriggered, reason) {
      const st = (await stateRef.get()).val() || {};
      if (st.phase !== "running") return;

      if (st.gameEndsAt && now() >= st.gameEndsAt) {
        hostRunning = false;
        await stateRef.update({ phase:"stopped", hostRunning:false });
        return;
      }

      const gameDevices = await getConnectedGameDevices();
      const nPlayers = clamp(parseInt(st.playersCount||4,10),2,10);
      if (gameDevices.length < nPlayers) {
        hostRunning = false;
        await stateRef.update({ phase:"stopped", hostRunning:false });
        return;
      }

      let dc = st.deviceColors || {};
      let shownAtMap = st.shownAtMap || {};

      for (const id of gameDevices) if (!(id in dc)) dc[id] = null;
      for (const id of Object.keys(dc)) {
        if (!gameDevices.includes(id)) {
          delete dc[id];
          delete shownAtMap[id];
        }
      }

      const currentColorKey = dc[deviceIdThatTriggered] || null;
      if (!currentColorKey) return;

      const dur = clamp(parseInt(st.durationMs||1800,10),200,20000);

      if (reason === "tap") {
        const tShown = shownAtMap[deviceIdThatTriggered] || st.gameStartedAt || now();
        const reaction = Math.max(0, now() - tShown);

        await playersRef.child(currentColorKey).transaction(p => {
          if (!p) return p;
          p.hits = (p.hits||0) + 1;
          p.totalMs = (p.totalMs||0) + reaction;
          return p;
        });
      } else if (reason === "timeout") {
        await playersRef.child(currentColorKey).transaction(p => {
          if (!p) return p;
          p.miss = (p.miss||0) + 1;
          return p;
        });
      }

      const idle = getIdleDevices(dc);
      const colored = getColoredDevices(dc);
      const hasIdle = idle.length > 0;

      if (hasIdle) {
        const targetIdle = idle[randInt(0, idle.length-1)];
        dc[deviceIdThatTriggered] = null;
        delete shownAtMap[deviceIdThatTriggered];
        dc[targetIdle] = currentColorKey;
        shownAtMap[targetIdle] = now();
      } else {
        const others = colored.filter(d => d !== deviceIdThatTriggered);
        if (others.length === 0) return;
        const swapWith = others[randInt(0, others.length-1)];
        const otherColorKey = dc[swapWith];

        dc[deviceIdThatTriggered] = otherColorKey;
        dc[swapWith] = currentColorKey;

        shownAtMap[deviceIdThatTriggered] = now();
        shownAtMap[swapWith] = now();
      }

      // pojistka invariantu: ka≈æd√° z prvn√≠ch N barev pr√°vƒõ jednou
      const activeKeys = getActiveColorKeys(nPlayers);
      const count = {};
      for (const k of activeKeys) count[k]=0;
      for (const d of Object.keys(dc)) {
        const c = dc[d];
        if (c && (c in count)) count[c]++;
      }
      const bad = activeKeys.some(k => count[k] !== 1);
      if (bad) {
        const rebuilt = buildInitialDeviceColors(gameDevices, nPlayers);
        dc = rebuilt.dc;
        shownAtMap = rebuilt.shownAtMap;
      }

      const newRound = (st.round||0) + 1;

      await stateRef.update({
        deviceColors: dc,
        shownAtMap: shownAtMap,
        round: newRound
      });
    }

    async function hostTick() {
      if (!isHost || !hostRunning) return;
      await hostPruneGhosts();
      const st = (await stateRef.get()).val() || {};
      if (st.phase !== "running") return;

      if (st.gameEndsAt && now() >= st.gameEndsAt) {
        hostRunning = false;
        await stateRef.update({ phase:"stopped", hostRunning:false });
        return;
      }

      const dur = clamp(parseInt(st.durationMs||1800,10),200,20000);
      const dc = st.deviceColors || {};
      const shownAtMap = st.shownAtMap || {};

      for (const devId of Object.keys(dc)) {
        const colorKey = dc[devId];
        if (!colorKey) continue;

        const tShown = shownAtMap[devId] || 0;
        if (tShown && (now() - tShown) >= dur) {
          await hostHandleEventForDevice(devId, "timeout");
          return;
        }
      }
    }

    async function onAction(act) {
      if (!isHost) return;
      if (!hostRunning) return;
      if (!act || act.type !== "tap") return;

      const st = (await stateRef.get()).val() || {};
      if (st.phase !== "running") return;

      const dc = st.deviceColors || {};
      if (!dc[act.deviceId]) return;

      await hostHandleEventForDevice(act.deviceId, "tap");
    }

fs.addEventListener("pointerdown", async (e) => {
  // jen prim√°rn√≠ dotyk (v√≠ce prst≈Ø => jen jeden se poƒç√≠t√°)
  if (e.isPrimary === false) return;

  if (!roomCode) return;

  if (tapLocked) return;      // üö´ dal≈°√≠ dotyky ignoruj
  tapLocked = true;           // üîí zamkni tap hned

  keepAwakeStart();
  e.preventDefault();

  // ‚ö° okam≈æitƒõ schovej barvu (lok√°lnƒõ)
  hideFullscreen();
  showIdle();

  try {
    await actionsRef.push({ type:"tap", deviceId, at: now() });
  } catch {}

  // ‚ùó NEODEMYKEJ tady ‚Äì odemkne se a≈æ kdy≈æ dostane≈° novou barvu
});


    // Buttons
    btnRandom.onclick = () => { codeInput.value = genCode(); };

    btnJoin.onclick = async () => {
      const code = (codeInput.value||"").trim();
      if (!/^\d{5}$/.test(code)) { alert("Zadej 5 ƒç√≠slic."); return; }
      await joinOrCreate(code);
      joinCard.style.display = "none";
    };

    btnApply.onclick = async () => {
      if (!isHost) return;
      await initRoomDefaults();
      alert("Nastaven√≠ ulo≈æeno.");
    };

    btnReset.onclick = async () => {
      if (!isHost) return;
      const snap = await playersRef.get();
      const obj = snap.val() || {};
      const updates = {};
      for (const k of Object.keys(obj)) {
        updates[k + "/hits"] = 0;
        updates[k + "/miss"] = 0;
        updates[k + "/totalMs"] = 0;
      }
      await playersRef.update(updates);
      alert("Sk√≥re vynulov√°no.");
    };

    btnStart.onclick = async () => {
      if (!isHost) return;

      const nPlayers = clamp(parseInt(playersCount.value,10)||4,2,10);
      const gameDevices = await getConnectedGameDevices();

      if (gameDevices.length < nPlayers) {
        alert(`Nelze spustit hru.\nHr√°ƒç≈Ø: ${nPlayers}\nHern√≠ch telefon≈Ø: ${gameDevices.length}\n(Poƒç√≠t√°no bez hosta)`);
        return;
      }

      hostRunning = true;

      // apply settings + reset round
      await initRoomDefaults();

      // clear actions
      try { await actionsRef.remove(); } catch {}

      const gls = clamp(parseInt(gameLengthSec.value,10)||60,1,36000);
      const startedAt = now();
      const endsAt = startedAt + gls*1000;

      const init = buildInitialDeviceColors(gameDevices, nPlayers);

      await stateRef.update({
        phase:"running",
        hostRunning:true,
        round:0,
        gameStartedAt: startedAt,
        gameEndsAt: endsAt,
        deviceColors: init.dc,
        shownAtMap: init.shownAtMap
      });

      clearTimeout(stopTimer);
      stopTimer = setTimeout(async ()=>{
        try { await stateRef.update({ phase:"stopped", hostRunning:false }); } catch {}
      }, gls*1000 + 50);

      if (hostTickTimer) clearInterval(hostTickTimer);
      hostTickTimer = setInterval(()=>{ hostTick().catch(()=>{}); }, 150);
    };

    btnStop.onclick = async () => {
      if (!isHost) return;
      hostRunning = false;
      clearTimeout(stopTimer);
      if (hostTickTimer) { clearInterval(hostTickTimer); hostTickTimer = null; }
      keepAwakeStop();
      stopHostCountdown();
      await stateRef.update({ phase:"stopped", hostRunning:false });
    };
  </script>
  <script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', async () => {
      try {
        const reg = await navigator.serviceWorker.register('./sw.js', { scope: './' });
        // volitelnƒõ: console.log('SW registered', reg.scope);
      } catch (e) {
        console.error('SW register failed', e);
      }
    });
  }
</script>

</body>
</html>
